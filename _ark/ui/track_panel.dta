#define TRACK_END_FRAME
(1920)

#define FASTERMODE_FASTER
(
   {if {modifier_mgr is_modifier_active mod_fastermode} ;check if we are in acceleration mode
      {unless {>= $speedmod $speedmod_cap} ;only run the following script if we are currently below our max speed cap
         {set $speedmod {+ $speedmod 0.002}} ;add a small amount of speed to the current song speed on note hit
         {beatmatch set_music_speed $speedmod} ;apply that speed in game
         {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;try (and fail) to match track speed to the current song speed
         {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}} ;try (and fail) to match track speed to the current song speed
         {{{gamemode get track_panel} find mtv_overlay} setup_text} ;refresh the mtv overlay to show the current song speed
         {if {> $speedmod $speedmod_top} ;if our current speed is higher than the top speed the player has reached in this run
            {set $speedmod_top $speedmod} ;set the top reached speed to the current speed
         }
      }
   }
)
#define FASTERMODE_SLOWER
(
   {if {modifier_mgr is_modifier_active mod_fastermode} ;check if we are in acceleration mode
      {unless {<= $speedmod $leaderspeed} ;only run the following script if we are currently above our original speed
         {set $speedmod {- $speedmod 0.004}} ;remove a greater amount of speed than we add, to the current song speed on note miss/pass
         {beatmatch set_music_speed $speedmod} ;apply that speed in game
         {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;try (and fail) to match track speed to the current song speed
         {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}} ;try (and fail) to match track speed to the current song speed
         {{{gamemode get track_panel} find mtv_overlay} setup_text} ;refresh the mtv overlay to show the current song speed
      }
   }
)
#define RESET_GEM_CALLBACK
(
   {set [num_gems_hit] 0} ;reset our current callback tracker back to 0 to begin new tracking
   {set [num_gems_miss] 0} ;reset our current callback tracker back to 0 to begin new tracking
   {set [num_gems_pass] 0} ;reset our current callback tracker back to 0 to begin new tracking
   {set [num_gems_combo] 0} ;reset our current callback tracker back to 0 to begin new tracking
)
#define FRAME_CATCHER
(
   {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}} ;remove the FC ring and replace it with the normal ring (the player just missed)
)
#define MISS_CATCHER
(
   {beatmatch foreach_active_player $player ;handle adding the appropriate callbacks to each player
      {switch {$player instrument} ;switch based off the currently loaded instrument
         (bass {if {! $bass_caughtmissed} {set $bass_caughtmissed TRUE} FRAME_CATCHER}) ;if the player has not missed yet, track that the player just missed, remove fc ring as in macro above
         (real_guitar {if {! $real_guitar_caughtmissed} {set $real_guitar_caughtmissed TRUE} FRAME_CATCHER}) ;if the player has not missed yet, track that the player just missed, remove fc ring as in macro above
         (real_bass {if {! $real_bass_caughtmissed} {set $real_bass_caughtmissed TRUE} FRAME_CATCHER}) ;if the player has not missed yet, track that the player just missed, remove fc ring as in macro above
         (keys {if {! $keys_caughtmissed} {set $keys_caughtmissed TRUE} FRAME_CATCHER}) ;if the player has not missed yet, track that the player just missed, remove fc ring as in macro above
         (real_keys {if {! $real_keys_caughtmissed} {set $real_keys_caughtmissed TRUE} FRAME_CATCHER}) ;if the player has not missed yet, track that the player just missed, remove fc ring as in macro above
         (guitar {if {! $guitar_caughtmissed} {set $guitar_caughtmissed TRUE} FRAME_CATCHER}) ;if the player has not missed yet, track that the player just missed, remove fc ring as in macro above
         (drum {if {! $drum_caughtmissed} {set $drum_caughtmissed TRUE} FRAME_CATCHER}) ;if the player has not missed yet, track that the player just missed, remove fc ring as in macro above
         (real_drum {if {! $real_drum_caughtmissed} {set $real_drum_caughtmissed TRUE} FRAME_CATCHER}) ;if the player has not missed yet, track that the player just missed, remove fc ring as in macro above
      }
   }
)
(new Object fc_callback ;the main callback for all instruments
   (hit ;when a note is hit
      {beatmatch foreach_active_player $player ;handle adding the appropriate callbacks to each player
         {switch {$player instrument} ;switch based off the currently loaded instrument
            (bass
               {if {! $bass_firstnote} {set $bass_firstnote TRUE}} ;if the first note has not been hit/missed/passed yet, track that the first note has been hit/missed/passed
               {if {! $bass_milosong} {set $bass_milosong TRUE} RESET_GEM_CALLBACK} ;milosong is another tracker to indicate we are at the beginning of a song. reset our counters if so
            )
            (real_guitar
               {if {! $real_guitar_firstnote} {set $real_guitar_firstnote TRUE}} ;if the first note has not been hit/missed/passed yet, track that the first note has been hit/missed/passed
               {if {! $real_guitar_milosong} {set $real_guitar_milosong TRUE} RESET_GEM_CALLBACK} ;milosong is another tracker to indicate we are at the beginning of a song. reset our counters if so
            )
            (real_bass
               {if {! $real_bass_firstnote} {set $real_bass_firstnote TRUE}} ;if the first note has not been hit/missed/passed yet, track that the first note has been hit/missed/passed
               {if {! $real_bass_milosong} {set $real_bass_milosong TRUE} RESET_GEM_CALLBACK} ;milosong is another tracker to indicate we are at the beginning of a song. reset our counters if so
            )
            (real_keys
               {if {! $real_keys_firstnote} {set $real_keys_firstnote TRUE}} ;if the first note has not been hit/missed/passed yet, track that the first note has been hit/missed/passed
               {if {! $real_keys_milosong} {set $real_keys_milosong TRUE} RESET_GEM_CALLBACK} ;milosong is another tracker to indicate we are at the beginning of a song. reset our counters if so
            )
            (keys
               {if {! $keys_firstnote} {set $keys_firstnote TRUE}} ;if the first note has not been hit/missed/passed yet, track that the first note has been hit/missed/passed
               {if {! $keys_milosong} {set $keys_milosong TRUE} RESET_GEM_CALLBACK} ;milosong is another tracker to indicate we are at the beginning of a song. reset our counters if so
            )
            (guitar
               {if {! $guitar_firstnote} {set $guitar_firstnote TRUE}} ;if the first note has not been hit/missed/passed yet, track that the first note has been hit/missed/passed
               {if {! $guitar_milosong} {set $guitar_milosong TRUE} RESET_GEM_CALLBACK} ;milosong is another tracker to indicate we are at the beginning of a song. reset our counters if so
            )
            (drum
               {if {! $drum_firstnote} {set $drum_firstnote TRUE}} ;if the first note has not been hit/missed/passed yet, track that the first note has been hit/missed/passed
               {if {! $drum_milosong} {set $drum_milosong TRUE} RESET_GEM_CALLBACK} ;milosong is another tracker to indicate we are at the beginning of a song. reset our counters if so
            )
            (real_drum
               {if {! $real_drum_firstnote} {set $real_drum_firstnote TRUE}} ;if the first note has not been hit/missed/passed yet, track that the first note has been hit/missed/passed
               {if {! $real_drum_milosong} {set $real_drum_milosong TRUE} RESET_GEM_CALLBACK} ;milosong is another tracker to indicate we are at the beginning of a song. reset our counters if so
            )
         }
      }
      {$this check_fc} ;run the logic to check if we are in an fc or not
      {set [num_gems_hit] {'+' [num_gems_hit] 1}} ;increment the notes hit counter
      {set [num_gems_combo] {'+' [num_gems_combo] 1}} ;increment the notes comboed counter
      FASTERMODE_FASTER ;speed up the song a little if in acceleration mode
   )
   (miss ;when a note is missed (overstrum)
      {unless ;do not run the following code unless the first note of the current track has been hit/missed/passed
         {beatmatch foreach_active_player $player ;handle adding the appropriate callbacks to each player
            {switch {$player instrument} ;switch based off the currently loaded instrument
               (bass {! $bass_firstnote}) ;if the first note has not been hit/missed/passed yet
               (real_guitar {! $real_guitar_firstnote}) ;if the first note has not been hit/missed/passed yet
               (real_bass {! $real_bass_firstnote}) ;if the first note has not been hit/missed/passed yet
               (keys {! $keys_firstnote}) ;if the first note has not been hit/missed/passed yet
               (real_keys {! $real_keys_firstnote}) ;if the first note has not been hit/missed/passed yet
               (guitar {! $guitar_firstnote}) ;if the first note has not been hit/missed/passed yet
               (drum {! $drum_firstnote}) ;if the first note has not been hit/missed/passed yet
               (real_drum {! $real_drum_firstnote}) ;if the first note has not been hit/missed/passed yet
            }
         }
         {set [num_gems_miss] {'+' [num_gems_miss] 1}} ;increment the notes missed counter
         {set [num_gems_combo] 0} ;reset the notes comboed counter
         {$this check_missed} ;run the logic to check our current misses
         MISS_CATCHER ;logic to remove the fc indicator upon miss/pass
         FASTERMODE_SLOWER
      }
   )
   (pass ;when a note is passed (ignored)
      {set [num_gems_pass] {'+' [num_gems_pass] 1}} ;increment the notes passed counter
      {set [num_gems_combo] 0} ;reset the notes comboed counter
      {$this check_missed} ;run the logic to check our current misses
      MISS_CATCHER ;logic to remove the fc indicator upon miss/pass
      FASTERMODE_SLOWER
   )
   (check_fc
      {$this check_missed} ;run the logic to check our current misses
      {if {== {'+' [num_gems_pass] [num_gems_miss]} 0} ;check that if we add our notes passed and notes missed together, it still equals 0 (fc)
         {set $fc TRUE} ;tell the logic that we are still fc'ing
      }
   )
   (check_missed
      {if {> {'+' [num_gems_miss] [num_gems_pass]} 0} ;check that if we add our notes passed and notes missed together, it is any number higher than 0 (non fc)
         MISS_CATCHER ;logic to remove the fc indicator upon miss/pass
      }
   )
   (num_gems_hit 0) ;default setup state and storage for note counters
   (num_gems_combo 0) ;default setup state and storage for note counters
   (num_gems_miss 0) ;default setup state and storage for note counters
   (num_gems_pass 0) ;default setup state and storage for note counters
)
#define TRACK_TEXTURE_HANDLER
(
;populate animated smasher bitmaps
{if $animatedsmasherscustomtexture ;if we have an animated smasher update queued
   {if $animatedsmashers ;if we have animated smashers enabled
      {set $framecountbit 0} ;we need to ensure we start at 0 before running the following task
      {thread_task kTaskSeconds ;create a new task
         (script
            {if {|| {$user get_track_type} kTrackGuitar kTrackBass kTrackKeys} ;check the currently loaded instrument
               {new Tex {sprint "guitarframe" $framecountbit ".tex"}} ;create a new texture with a numerical index of the currently tracked variable for it's specific instrument smasher type
               {{sprint "guitarframe" $framecountbit ".tex"} set_bitmap {sprint "ui/track/animated_smashers/gem_smasher_guitar_" $animatedsmashername "/gem_smasher_guitar_" $animatedsmashername "_" $framecountbit ".png"}} ;populate the currently created texture index with the selected animated smasher index for it's specific instrument smashers type
            }
            {if {== {$user get_track_type} kTrackDrum} ;check the currently loaded instrument
               {new Tex {sprint "drumframe" $framecountbit ".tex"}} ;create a new texture with a numerical index of the currently tracked variable for it's specific instrument smasher type
               {{sprint "drumframe" $framecountbit ".tex"} set_bitmap {sprint "ui/track/animated_smashers/gem_smasher_drum_" $animatedsmashername "/gem_smasher_drum_" $animatedsmashername "_" $framecountbit ".png"}} ;populate the currently created texture index with the selected animated smasher index for it's specific instrument smashers type
            }
            {set $framecountbit {+ $framecountbit 1}} ;increment the variable to setup the next texture creation index
            {unless {>= $framecountbit 60} ;only run the task until the variable reaches 60
               {$task loop} ;loop the task if variable is below 60
            }
         )
      }
   }
}

;apply animated smasher in game task
{if {exists animated_smashers} ;check if the above task is running
   {delete animated_smashers} ;delete the task if running
}
{if $animatedsmashers ;if we have animated smashers enabled
   {set $framecountdif 0} ;we need to ensure we start at 0 before running the following task
   {thread_task kTaskSeconds ;create a new task
      (delay 0.4) ;delay the start of the task
      (name animated_smashers) ;name the current task for deletion tracking
      (script ;task contents
         {if {== {$user get_track_type} kTrackDrum} ;check the currently loaded instrument
            {gem_smasher_drum.mat set diffuse_tex {sprint "drumframe" $framecountdif ".tex"}} ;apply the currently selected animated texture index with the selected animated smasher index image we pre generated
         }
         {if {|| {$user get_track_type} kTrackGuitar kTrackBass kTrackKeys} ;check the currently loaded instrument
            {gem_smasher_guitar.mat set diffuse_tex {sprint "guitarframe" $framecountdif ".tex"}} ;apply the currently selected animated texture index with the selected animated smasher index image we pre generated
         }
         {set $framecountdif {+ $framecountdif 1}} ;increment the variable to setup the next texture application index
         {$task sleep 0.016} ;delay the next step of the task for roughly 1 frame at 60fps
         {if {>= $framecountdif 60} {set $framecountdif 0}} ;only run the task until the variable reaches 60
         {$task loop} ;loop the task
      )
   }
}

;populate memory with animated gems textures for replacement
{if $animatedgemscustomtexture ;if we have an animated gem update queued
   {if $animatedgems ;if we have animated gems enabled
      {set $gemframecounttex 0} ;we need to ensure we start at 0 before running the following task
      {thread_task kTaskSeconds ;create a new task
         (script ;task contents
            {if {|| {$user get_track_type} kTrackDrum kTrackGuitar kTrackBass kTrackKeys kTrackRealKeys} ;check the currently loaded instrument
               {new Tex {sprint "gemframe" $gemframecounttex ".tex"}} ;create a new texture with a numerical index of the currently tracked variable for it's specific instrument gem type
               {{sprint "gemframe" $gemframecounttex ".tex"} set_bitmap {sprint "ui/track/animated_gems/prism_gems_" $animatedgemname "/prism_gems_" $animatedgemname "_" $gemframecounttex ".png"}} ;populate the currently created texture index with the selected animated gem index for it's specific instrument gem type
            }
            {if {== {$user get_track_type} kTrackDrum} ;check the currently loaded instrument
               {new Tex {sprint "gemdrumframe" $gemframecounttex ".tex"}} ;create a new texture with a numerical index of the currently tracked variable for it's specific instrument gem type
               {{sprint "gemdrumframe" $gemframecounttex ".tex"} set_bitmap {sprint "ui/track/animated_gems/gem_cymbal_diffuse_" $animatedgemname "/gem_cymbal_diffuse_" $animatedgemname "_" $gemframecounttex ".png"}} ;populate the currently created texture index with the selected animated gem index for it's specific instrument gem type
            }
            {if {== {$user get_track_type} kTrackRealKeys} ;check the currently loaded instrument
               {new Tex {sprint "gemkeysframe" $gemframecounttex ".tex"}} ;create a new texture with a numerical index of the currently tracked variable for it's specific instrument gem type
               {{sprint "gemkeysframe" $gemframecounttex ".tex"} set_bitmap {sprint "ui/track/animated_gems/prism_gem_keyboard_style_" $animatedgemname "/prism_gem_keyboard_style_" $animatedgemname "_" $gemframecounttex ".png"}} ;populate the currently created texture index with the selected animated gem index for it's specific instrument gem type
            }
            {set $gemframecounttex {+ $gemframecounttex 1}} ;increment the variable to setup the next texture creation index
            {unless {>= $gemframecounttex 60} ;only run the task until the variable reaches 60
               {$task loop} ;loop the task if variable is below 60
            }
         )
      }
   }
}

;apply animated gems in game task
{if {exists animated_gems} ;check if the above task is running
   {delete animated_gems} ;delete the task if running
}
{if $animatedgems ;if we have animated gem enabled
   {set $gemframecountdif 0} ;we need to ensure we start at 0 before running the following task
   {thread_task kTaskSeconds ;create a new task
      (name animated_gems) ;name the current task for deletion tracking
      (delay 0.1) ;delay the start of the task
      (script ;task contents
         {if {== {$user get_track_type} kTrackDrum} ;check the currently loaded instrument
            {gem_cymbal_diffuse.tex iterate_refs $ref {$ref set diffuse_tex {sprint "gemdrumframe" $gemframecountdif '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {gem_cymbal_diffuse.tex iterate_refs $ref {$ref set emissive_map {sprint "gemdrumframe" $gemframecountdif '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {gem_cymbal_diffuse.tex iterate_refs $ref {$ref set normal_map {sprint "gemdrumframe" $gemframecountdif '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {gem_cymbal_ems.tex iterate_refs $ref {$ref set diffuse_tex {sprint "gemdrumframe" $gemframecountdif '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
         }
         {if {|| {$user get_track_type} kTrackDrum kTrackGuitar kTrackBass kTrackKeys kTrackRealKeys} ;check the currently loaded instrument
            {prism_gems.tex iterate_refs $ref {$ref set diffuse_tex {sprint "gemframe" $gemframecountdif '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {prism_gems.tex iterate_refs $ref {$ref set emissive_map {sprint "gemframe" $gemframecountdif '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {prism_gems.tex iterate_refs $ref {$ref set normal_map {sprint "gemframe" $gemframecountdif '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {prism_gem_emissive.tex iterate_refs $ref {$ref set diffuse_tex {sprint "gemframe" $gemframecountdif '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
         }
         {if {== {$user get_track_type} kTrackRealKeys} ;check the currently loaded instrument
            {prism_gem_keyboard_style.tex iterate_refs $ref {$ref set diffuse_tex {sprint "gemkeysframe" $gemframecountdif '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
         }
         {set $gemframecountdif {+ $gemframecountdif 1}} ;increment the variable to setup the next texture application index
         {$task sleep 0.016} ;delay the next step of the task for roughly 1 frame at 60fps
         {if {>= $gemframecountdif 60} {set $gemframecountdif 0}} ;only run the task until the variable reaches 60
         {$task loop} ;loop the task
      )
   }
}

;populate animated highway bitmaps
{if $animatedhighwaycustomtexture ;if we have an animated highway update queued
   {if $animatedhighway ;if we have animated highway enabled
      {set $highframecountbit 0} ;we need to ensure we start at 0 before running the following task
      {thread_task kTaskSeconds ;create a new task
         (script ;task contents
            {new Tex {sprint "highframe" $highframecountbit ".tex"}} ;create a new texture with a numerical index of the currently tracked variable
            {{sprint "highframe" $highframecountbit ".tex"} set_bitmap {sprint "ui/track/animated_surfaces/" $animatedhighwayname "/" $animatedhighwayname "_" $highframecountbit ".png"}} ;populate the currently created texture index with the selected animated highway index
            {set $highframecountbit {+ $highframecountbit 1}} ;increment the variable to setup the next texture creation index
            {unless {>= $highframecountbit 60} ;only run the task until the variable reaches 60
               {$task loop} ;loop the task if variable is below 60
            }
         )
      }
   }
}

{if {exists animated_highway} ;check if the above task is running
   {delete animated_highway} ;delete the task if running
}
;apply animated highway in game task
{if $animatedhighway ;if we have animated highway enabled
   {set $highframecount 0} ;we need to ensure we start at 0 before running the following task
   {thread_task kTaskSeconds ;create a new task
      (name animated_highway) ;name the current task for deletion tracking
      (delay 0.1) ;delay the start of the task
      (script ;task contents
         {if {|| {$user get_track_type} kTrackBass kTrackGuitar kTrackRealBass kTrackRealGuitar} ;check the currently loaded instrument
            {watermark_bass.tex set_bitmap {sprint "ui/track/highways/_no_highway.png"}} ;hide the original texture that we aren"t using during animated highway mode
            {watermark_guitar.tex set_bitmap {sprint "ui/track/highways/_no_highway.png"}} ;hide the original texture that we aren"t using during animated highway mode
            {watermark_bass.tex iterate_refs $ref {$ref set prelit FALSE}} ;setting prelit to false makes the highways pop visually
            {watermark_guitar.tex iterate_refs $ref {$ref set prelit FALSE}} ;setting prelit to false makes the highways pop visually
            {watermark_bass.tex iterate_refs $ref {$ref set diffuse_tex {sprint "highframe" $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {watermark_bass.tex iterate_refs $ref {$ref set emissive_map {sprint "highframe" $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {watermark_bass.tex iterate_refs $ref {$ref set normal_map {sprint "highframe" $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {watermark_guitar.tex iterate_refs $ref {$ref set diffuse_tex {sprint "highframe" $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {watermark_guitar.tex iterate_refs $ref {$ref set emissive_map {sprint "highframe" $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {watermark_guitar.tex iterate_refs $ref {$ref set normal_map {sprint "highframe" $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
         }
         {if {== {$user get_track_type} kTrackDrum} ;check the currently loaded instrument
            {watermark_drum.tex set_bitmap {sprint "ui/track/highways/_no_highway.png"}} ;hide the original texture that we aren"t using during animated highway mode
            {watermark_drum.tex iterate_refs $ref {$ref set prelit FALSE}} ;setting prelit to false makes the highways pop visually
            {watermark_drum.tex iterate_refs $ref {$ref set diffuse_tex {sprint "highframe" $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {watermark_drum.tex iterate_refs $ref {$ref set emissive_map {sprint "highframe" $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {watermark_drum.tex iterate_refs $ref {$ref set normal_map {sprint "highframe" $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
         }
         {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check the currently loaded instrument
            {watermark_keys.tex set_bitmap {sprint "ui/track/highways/_no_highway.png"}} ;hide the original texture that we aren"t using during animated highway mode
            {watermark_keys.tex iterate_refs $ref {$ref set prelit FALSE}} ;setting prelit to false makes the highways pop visually
            {watermark_keys.tex iterate_refs $ref {$ref set diffuse_tex {sprint "highframe" $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {watermark_keys.tex iterate_refs $ref {$ref set emissive_map {sprint "highframe" $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {watermark_keys.tex iterate_refs $ref {$ref set normal_map {sprint "highframe" $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
         }
         {set $highframecount {+ $highframecount 1}} ;increment the variable to setup the next texture application index
         {$task sleep 0.041} ;delay the next step of the task for roughly 1 frame at 30fps
         {if {>= $highframecount 60} {set $highframecount 0}} ;only run the task until the variable reaches 60
         {$task loop} ;loop the task
      )
   }
}

{if_else $fcringonce ;check if we have already generated new textures for the fc ring
   {do ;if we have
      {{coop_track_panel find fcframe.tex} set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_plate_fc_" $multiring ".png"}} ;load texture onto the generated texture
      {{coop_track_panel find multframe.tex} set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_plate_" $multiring ".png"}} ;load texture onto the generated texture
      {{coop_track_panel find streak_meter_plate.tex} iterate_refs $ref {$ref set diffuse_tex fcframe.tex}} ;apply the fc texture to the ring material
      {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex fcframe.tex}} ;apply the fc texture to the ring material
      ;{{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set emissive_map fcframe.tex}} ;apply the fc texture to the ring material
      ;{{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set normal_map fcframe.tex}} ;apply the fc texture to the ring material
      {{coop_track_panel find multframe.tex} iterate_refs $ref {$ref set diffuse_tex fcframe.tex}} ;apply the multiplier texture to the second ring material
      ;{{coop_track_panel find multframe.tex} iterate_refs $ref {$ref set emissive_map fcframe.tex}} ;apply the multiplier texture to the second ring material
      ;{{coop_track_panel find multframe.tex} iterate_refs $ref {$ref set normal_map fcframe.tex}} ;apply the multiplier texture to the second ring material
   }
   {do ;if we havent
      {set $fcringonce TRUE} ;ensure this task does not run again until reboot (texture stays in memory)
      {new Tex fcframe.tex} ;generate a new texture to hold the fc indicator
      {new Tex multframe.tex} ;generate a new texture to hold the non fc texture
      {{coop_track_panel find streak_meter_plate.tex} iterate_refs $ref {$ref set diffuse_tex fcframe.tex}} ;apply the fc texture to the ring material
      ;{{coop_track_panel find streak_meter_plate.tex} iterate_refs $ref {$ref set emissive_map fcframe.tex}} ;apply the fc texture to the ring material
      ;{{coop_track_panel find streak_meter_plate.tex} iterate_refs $ref {$ref set normal_map fcframe.tex}} ;apply the fc texture to the ring material
      {{coop_track_panel find fcframe.tex} set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_plate_fc_" $multiring ".png"}} ;load texture onto the generated texture
      {{coop_track_panel find multframe.tex} set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_plate_" $multiring ".png"}} ;load texture onto the generated texture
   }
}

;setup emissive textures per instrument to use later
#define GTR_EMISSIVE_HANDLER
(
   {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} ;check if the instrument is currently loaded on screen
      {spotlight_guitar_track_emissive.tex set_bitmap {sprint "ui/track/emissives/" $emissivegtr ".png"}} ;load selected texture into tex memory
      {spotlight_guitar_track_emissive.tex iterate_refs $ref {$ref set diffuse_tex spotlight_guitar_track_emissive.tex}} ;load the tex into the material
      {spotlight_guitar_track_emissive.tex iterate_refs $ref {$ref set emissive_map spotlight_guitar_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_guitar_track_emissive.tex iterate_refs $ref {$ref set normal_map spotlight_guitar_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_guitar_track_emissive.tex iterate_refs $ref {$ref set color {pack_color $emissive_r $emissive_g $emissive_b}}} ;apply the custom color selected to the material
      {spotlight_guitar_track_emissive.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)

#define BASS_EMISSIVE_HANDLER
(
   {if {|| {$user get_track_type} kTrackBass kTrackRealBass} ;check if the instrument is currently loaded on screen
      {spotlight_bass_track_emissive.tex set_bitmap {sprint "ui/track/emissives/" $emissivebass ".png"}} ;load selected texture into tex memory
      {spotlight_bass_track_emissive.tex iterate_refs $ref {$ref set diffuse_tex spotlight_bass_track_emissive.tex}} ;load the tex into the material
      {spotlight_bass_track_emissive.tex iterate_refs $ref {$ref set emissive_map spotlight_bass_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_bass_track_emissive.tex iterate_refs $ref {$ref set normal_map spotlight_bass_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_bass_track_emissive.tex iterate_refs $ref {$ref set color {pack_color $emissive_r $emissive_g $emissive_b}}} ;apply the custom color selected to the material
      {spotlight_bass_track_emissive.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)

#define DRUM_EMISSIVE_HANDLER
(
   {if {== {$user get_track_type} kTrackDrum} ;check if the instrument is currently loaded on screen
      {spotlight_drums_track_emissive.tex set_bitmap {sprint "ui/track/emissives/" $emissivedrum ".png"}} ;load selected texture into tex memory
      {spotlight_drums_track_emissive.tex iterate_refs $ref {$ref set diffuse_tex spotlight_drums_track_emissive.tex}} ;load the tex into the material
      {spotlight_drums_track_emissive.tex iterate_refs $ref {$ref set emissive_map spotlight_drums_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_drums_track_emissive.tex iterate_refs $ref {$ref set normal_map spotlight_drums_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_drums_track_emissive.tex iterate_refs $ref {$ref set color {pack_color $emissive_r $emissive_g $emissive_b}}} ;apply the custom color selected to the material
      {spotlight_drums_track_emissive.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)
#define KEYS_EMISSIVE_HANDLER
(
   {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
      {spotlight_keys_track_emissive.tex set_bitmap {sprint "ui/track/emissives/" $emissivekeys ".png"}} ;load selected texture into tex memory
      {spotlight_prokeys_track_emissive.tex set_bitmap {sprint "ui/track/emissives/" $emissivekeys ".png"}} ;load selected texture into tex memory
      {spotlight_keys_track_emissive.tex iterate_refs $ref {$ref set diffuse_tex spotlight_keys_track_emissive.tex}} ;load the tex into the material
      {spotlight_prokeys_track_emissive.tex iterate_refs $ref {$ref set diffuse_tex spotlight_prokeys_track_emissive.tex}} ;load the tex into the material
      {spotlight_keys_track_emissive.tex iterate_refs $ref {$ref set emissive_map spotlight_keys_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_keys_track_emissive.tex iterate_refs $ref {$ref set normal_map spotlight_keys_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_prokeys_track_emissive.tex iterate_refs $ref {$ref set emissive_map spotlight_prokeys_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_prokeys_track_emissive.tex iterate_refs $ref {$ref set normal_map spotlight_prokeys_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_keys_track_emissive.tex iterate_refs $ref {$ref set color {pack_color $emissive_r $emissive_g $emissive_b}}} ;apply the custom color selected to the material
      {spotlight_prokeys_track_emissive.tex iterate_refs $ref {$ref set color {pack_color $emissive_r $emissive_g $emissive_b}}} ;apply the custom color selected to the material
      {spotlight_keys_track_emissive.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
      {spotlight_prokeys_track_emissive.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)

{if $emissivecustomtexture ;if we are queued to update an emissive texture
   {unless {== $emissive none} ;check the texture is not set to default
      {if {== {$user get_track_type} kTrackDrum} ;check if the instrument is currently loaded on screen
         {set $emissivedrum $emissive} ;set the per instrument emissive temporarily to the overall emissive selected
         {set $emissivedrumcustomtexture TRUE} ;queue an update to the per instrument emissive of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackBass kTrackRealBass} ;check if the instrument is currently loaded on screen
         {set $emissivebass $emissive} ;set the per instrument emissive temporarily to the overall emissive selected
         {set $emissivebasscustomtexture TRUE} ;queue an update to the per instrument emissive of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} ;check if the instrument is currently loaded on screen
         {set $emissivegtr $emissive} ;set the per instrument emissive temporarily to the overall emissive selected
         {set $emissivegtrcustomtexture TRUE} ;queue an update to the per instrument emissive of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
         {set $emissivekeys $emissive} ;set the per instrument emissive temporarily to the overall emissive selected
         {set $emissivekeyscustomtexture TRUE} ;queue an update to the per instrument emissive of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
         {set $emissivekeys $emissive} ;set the per instrument emissive temporarily to the overall emissive selected
         {set $emissivekeyscustomtexture TRUE} ;queue an update to the per instrument emissive of a currently loaded instrument
      }
   }
}

{if $emissivegtrcustomtexture ;if we are queued to update a per instrument emissive texture
   {unless {== $emissivegtr none} ;check the texture is not set to default
      GTR_EMISSIVE_HANDLER ;apply the emissive to the instrument if available
      {unless {== $emissive none} ;if we came here from all instrument emissive
         {set $emissivegtr none} ;reset per inst emissive
      }
   }
}

{if $emissivebasscustomtexture ;if we are queued to update a per instrument emissive texture
   {unless {== $emissivebass none} ;check the texture is not set to default
      BASS_EMISSIVE_HANDLER ;apply the emissive to the instrument if available
      {unless {== $emissive none} ;if we came here from all instrument emissive
         {set $emissivebass none} ;reset per inst emissive
      }
   }
}

{if $emissivedrumcustomtexture ;if we are queued to update a per instrument emissive texture
   {unless {== $emissivedrum none} ;check the texture is not set to default
      DRUM_EMISSIVE_HANDLER ;apply the emissive to the instrument if available
      {unless {== $emissive none} ;if we came here from all instrument emissive
         {set $emissivedrum none} ;reset per inst emissive
      }
   }
}

{if $emissivekeyscustomtexture ;if we are queued to update a per instrument emissive texture
   {unless {== $emissivekeys none} ;check the texture is not set to default
      KEYS_EMISSIVE_HANDLER ;apply the emissive to the instrument if available
      {unless {== $emissive none} ;if we came here from all instrument emissive
         {set $emissivekeys none} ;reset per inst emissive
      }
   }
}

;setup spotlight textures per instrument to use later
#define GTR_SPOTLIGHT_HANDLER
(
   {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} ;check if the instrument is currently loaded on screen
      {spotlight_guitar_track.tex set_bitmap {sprint "ui/track/spotlights/" $spotlightgtr ".png"}} ;load selected texture into tex memory
      {spotlight_guitar_track.tex iterate_refs $ref {$ref set diffuse_tex spotlight_guitar_track.tex}} ;load the tex into the material
      {spotlight_guitar_track.tex iterate_refs $ref {$ref set emissive_map spotlight_guitar_track.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_guitar_track.tex iterate_refs $ref {$ref set normal_map spotlight_guitar_track.tex}} ;apply the emissive map as well so it looks proper
      ;{spotlight_guitar_track.tex iterate_refs $ref {$ref set color {pack_color $spotlight_r $spotlight_g $spotlight_b}}} ;apply the custom color selected to the material
      ;{spotlight_guitar_track.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)

#define BASS_SPOTLIGHT_HANDLER
(
   {if {|| {$user get_track_type} kTrackBass kTrackRealBass} ;check if the instrument is currently loaded on screen
      {spotlight_bass_track.tex set_bitmap {sprint "ui/track/spotlights/" $spotlightbass ".png"}} ;load selected texture into tex memory
      {spotlight_bass_track.tex iterate_refs $ref {$ref set diffuse_tex spotlight_bass_track.tex}} ;load the tex into the material
      {spotlight_bass_track.tex iterate_refs $ref {$ref set emissive_map spotlight_bass_track.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_bass_track.tex iterate_refs $ref {$ref set normal_map spotlight_bass_track.tex}} ;apply the emissive map as well so it looks proper
      ;{spotlight_bass_track.tex iterate_refs $ref {$ref set color {pack_color $spotlight_r $spotlight_g $spotlight_b}}} ;apply the custom color selected to the material
      ;{spotlight_bass_track.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)

#define DRUM_SPOTLIGHT_HANDLER
(
   {if {== {$user get_track_type} kTrackDrum} ;check if the instrument is currently loaded on screen
      {spotlight_drums_track.tex set_bitmap {sprint "ui/track/spotlights/" $spotlightdrum ".png"}} ;load selected texture into tex memory
      {spotlight_drum_track.tex iterate_refs $ref {$ref set diffuse_tex spotlight_drum_track.tex}} ;load the tex into the material
      {spotlight_drum_track.tex iterate_refs $ref {$ref set emissive_map spotlight_drum_track.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_drum_track.tex iterate_refs $ref {$ref set normal_map spotlight_drum_track.tex}} ;apply the emissive map as well so it looks proper
      ;{spotlight_drum_track.tex iterate_refs $ref {$ref set color {pack_color $spotlight_r $spotlight_g $spotlight_b}}} ;apply the custom color selected to the material
      ;{spotlight_drum_track.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)
#define KEYS_SPOTLIGHT_HANDLER
(
   {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
      {spotlight_prokeys_track.tex set_bitmap {sprint "ui/track/spotlights/" $spotlightkeys ".png"}} ;load selected texture into tex memory
      {spotlight_keys_track.tex set_bitmap {sprint "ui/track/spotlights/" $spotlightkeys ".png"}} ;load selected texture into tex memory
      {spotlight_prokeys_track.tex iterate_refs $ref {$ref set diffuse_tex spotlight_prokeys_track.tex}} ;load the tex into the material
      {spotlight_keys_track.tex iterate_refs $ref {$ref set diffuse_tex spotlight_keys_track.tex}} ;load the tex into the material
      {spotlight_keys_track.tex iterate_refs $ref {$ref set normal_map spotlight_keys_track.tex}} ;load the tex into the material
      {spotlight_prokeys_track.tex iterate_refs $ref {$ref set emissive_map spotlight_prokeys_track.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_keys_track.tex iterate_refs $ref {$ref set emissive_map spotlight_keys_track.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_keys_track.tex iterate_refs $ref {$ref set normal_map spotlight_keys_track.tex}} ;apply the emissive map as well so it looks proper
      ;{spotlight_prokeys_track.tex iterate_refs $ref {$ref set color {pack_color $spotlight_r $spotlight_g $spotlight_b}}} ;apply the custom color selected to the material
      ;{spotlight_keys_track.tex iterate_refs $ref {$ref set color {pack_color $spotlight_r $spotlight_g $spotlight_b}}} ;apply the custom color selected to the material
      ;{spotlight_prokeys_track.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
      ;{spotlight_keys_track.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)

{if $spotlightcustomtexture ;if we are queued to update an spotlight texture
   {unless {== $spotlight none} ;check the texture is not set to default
      {if {== {$user get_track_type} kTrackDrum} ;check if the instrument is currently loaded on screen
         {set $spotlightdrum $spotlight} ;set the per instrument spotlight temporarily to the overall spotlight selected
         {set $spotlightdrumcustomtexture TRUE} ;queue an update to the per instrument spotlight of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackBass kTrackRealBass} ;check if the instrument is currently loaded on screen
         {set $spotlightbass $spotlight} ;set the per instrument spotlight temporarily to the overall spotlight selected
         {set $spotlightbasscustomtexture TRUE} ;queue an update to the per instrument spotlight of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} ;check if the instrument is currently loaded on screen
         {set $spotlightgtr $spotlight} ;set the per instrument spotlight temporarily to the overall spotlight selected
         {set $spotlightgtrcustomtexture TRUE} ;queue an update to the per instrument spotlight of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
         {set $spotlightkeys $spotlight} ;set the per instrument spotlight temporarily to the overall spotlight selected
         {set $spotlightkeyscustomtexture TRUE} ;queue an update to the per instrument spotlight of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
         {set $spotlightkeys $spotlight} ;set the per instrument spotlight temporarily to the overall spotlight selected
         {set $spotlightkeyscustomtexture TRUE} ;queue an update to the per instrument spotlight of a currently loaded instrument
      }
   }
}

{if $spotlightgtrcustomtexture ;if we are queued to update a per instrument spotlight texture
   {unless {== $spotlightgtr none} ;check the texture is not set to default
      GTR_SPOTLIGHT_HANDLER ;apply the spotlight to the instrument if available
      {unless {== $spotlight none} ;if we came here from all instrument spotlight
         {set $spotlightgtr none} ;reset per inst spotlight
      }
   }
}

{if $spotlightbasscustomtexture ;if we are queued to update a per instrument spotlight texture
   {unless {== $spotlightbass none} ;check the texture is not set to default
      BASS_SPOTLIGHT_HANDLER ;apply the spotlight to the instrument if available
      {unless {== $spotlight none} ;if we came here from all instrument spotlight
         {set $spotlightbass none} ;reset per inst spotlight
      }
   }
}

{if $spotlightdrumcustomtexture ;if we are queued to update a per instrument spotlight texture
   {unless {== $spotlightdrum none} ;check the texture is not set to default
      DRUM_SPOTLIGHT_HANDLER ;apply the spotlight to the instrument if available
      {unless {== $spotlight none} ;if we came here from all instrument spotlight
         {set $spotlightdrum none} ;reset per inst spotlight
      }
   }
}

{if $spotlightkeyscustomtexture ;if we are queued to update a per instrument spotlight texture
   {unless {== $spotlightkeys none}
      KEYS_SPOTLIGHT_HANDLER ;apply the spotlight to the instrument if available
      {unless {== $spotlight none} ;if we came here from all instrument spotlight
         {set $spotlightkeys none} ;reset per inst spotlight
      }
   }
}

#define GTR_HIGHWAY_HANDLER
(
   {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} ;check if the instrument is currently loaded on screen
      {watermark_guitar.tex set_bitmap {sprint "ui/track/highways/" $highwaygtr ".png"}} ;load selected texture into tex memory
      {watermark_guitar.tex iterate_refs $ref {$ref set diffuse_tex watermark_guitar.tex}} ;load the tex into the material
      {watermark_guitar.tex iterate_refs $ref {$ref set emissive_map watermark_guitar.tex}} ;apply the emissive map as well so it looks proper
      {watermark_guitar.tex iterate_refs $ref {$ref set normal_map watermark_guitar.tex}} ;apply the emissive map as well so it looks proper
      {watermark_guitar.tex iterate_refs $ref {$ref set emissive_multiplier 0.8}} ;make the texture pop a bit, this also might not actually do anything for the highway idk
   }
)
#define BASS_HIGHWAY_HANDLER
(
   {if {|| {$user get_track_type} kTrackBass kTrackRealBass} ;check if the instrument is currently loaded on screen
      {watermark_bass.tex set_bitmap {sprint "ui/track/highways/" $highwaybass ".png"}} ;load selected texture into tex memory
      {watermark_bass.tex iterate_refs $ref {$ref set diffuse_tex watermark_bass.tex}} ;load the tex into the material
      {watermark_bass.tex iterate_refs $ref {$ref set emissive_map watermark_bass.tex}} ;apply the emissive map as well so it looks proper
      {watermark_bass.tex iterate_refs $ref {$ref set normal_map watermark_bass.tex}} ;apply the emissive map as well so it looks proper
      {watermark_bass.tex iterate_refs $ref {$ref set emissive_multiplier 0.8}} ;make the texture pop a bit, this also might not actually do anything for the highway idk
   }
)
#define DRUM_HIGHWAY_HANDLER
(
   {if {== {$user get_track_type} kTrackDrum} ;check if the instrument is currently loaded on screen
      {watermark_drum.tex set_bitmap {sprint "ui/track/highways/" $highwaydrum ".png"}} ;load selected texture into tex memory
      {watermark_drum.tex iterate_refs $ref {$ref set diffuse_tex watermark_drum.tex}} ;load the tex into the material
      {watermark_drum.tex iterate_refs $ref {$ref set emissive_map watermark_drum.tex}} ;apply the emissive map as well so it looks proper
      {watermark_drum.tex iterate_refs $ref {$ref set normal_map watermark_drum.tex}} ;apply the emissive map as well so it looks proper
      {watermark_drum.tex iterate_refs $ref {$ref set emissive_multiplier 0.8}} ;make the texture pop a bit, this also might not actually do anything for the highway idk
   }
)
#define KEYS_HIGHWAY_HANDLER
(
   {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
      {watermark_keys.tex set_bitmap {sprint "ui/track/highways/" $highwaykeys ".png"}} ;load selected texture into tex memory
      {watermark_keys.tex iterate_refs $ref {$ref set diffuse_tex watermark_keys.tex}} ;load the tex into the material
      {watermark_keys.tex iterate_refs $ref {$ref set emissive_map watermark_keys.tex}} ;apply the emissive map as well so it looks proper
      {watermark_keys.tex iterate_refs $ref {$ref set normal_map watermark_keys.tex}} ;apply the emissive map as well so it looks proper
      {watermark_keys.tex iterate_refs $ref {$ref set emissive_multiplier 0.8}} ;make the texture pop a bit, this also might not actually do anything for the highway idk
   }
)

{if $highwaycustomtexture ;if we are queued to update an highway texture
   {unless {== $highway none} ;check the texture is not set to default
      {if {== {$user get_track_type} kTrackDrum} ;check if the instrument is currently loaded on screen
         {set $highwaydrum $highway} ;set the per instrument highway temporarily to the overall highway selected
         {set $highwaydrumcustomtexture TRUE} ;queue an update to the per instrument highway of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackBass kTrackRealBass} ;check if the instrument is currently loaded on screen
         {set $highwaybass $highway} ;set the per instrument highway temporarily to the overall highway selected
         {set $highwaybasscustomtexture TRUE} ;queue an update to the per instrument highway of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} ;check if the instrument is currently loaded on screen
         {set $highwaydrum $highway} ;set the per instrument highway temporarily to the overall highway selected
         {set $highwaydrumcustomtexture TRUE} ;queue an update to the per instrument highway of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
         {set $highwaykeys $highway} ;set the per instrument highway temporarily to the overall highway selected
         {set $highwaykeyscustomtexture TRUE} ;queue an update to the per instrument highway of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
         {set $highwaykeys $highway} ;set the per instrument highway temporarily to the overall highway selected
         {set $highwaykeyscustomtexture TRUE} ;queue an update to the per instrument highway of a currently loaded instrument
      }
   }
}

{if $highwaygtrcustomtexture ;if we are queued to update a per instrument highway texture
   {unless {== $highwaygtr none} ;check the texture is not set to default
      GTR_HIGHWAY_HANDLER ;apply the highway to the instrument if available
      {unless {== $highway none} ;if we came here from all instrument highway
         {set $highwaygtr none} ;reset per inst highway
      }
   }
}

{if $highwaybasscustomtexture ;if we are queued to update a per instrument highway texture
   {unless {== $highwaybass none} ;check the texture is not set to default
      BASS_HIGHWAY_HANDLER ;apply the highway to the instrument if available
      {unless {== $highway none} ;if we came here from all instrument highway
         {set $highwaybass none} ;reset per inst highway
      }
   }
}

{if $highwaydrumcustomtexture ;if we are queued to update a per instrument highway texture
   {unless {== $highwaydrum none} ;check the texture is not set to default
      DRUM_HIGHWAY_HANDLER ;apply the highway to the instrument if available
      {unless {== $highway none} ;if we came here from all instrument highway
         {set $highwaydrum none} ;reset per inst highway
      }
   }
}

{if $highwaykeyscustomtexture ;if we are queued to update a per instrument highway texture
   {unless {== $highwaykeys none} ;check the texture is not set to default
      KEYS_HIGHWAY_HANDLER ;apply the highway to the instrument if available
      {unless {== $highway none} ;if we came here from all instrument highway
         {set $highwaykeys none} ;reset per inst highway
      }
   }
}

{if $crowdmetercustomtexture ;check if a new texture is queued
   {unless {== $crowdmeter none} ;check the texture is not set to default
      {crowd_meter_frame.tex set_bitmap {sprint "ui/track/crowd_meter/crowd_meter_frame_" $crowdmeter ".png"}}
      {crowd_meter_lens.tex set_bitmap {sprint "ui/track/crowd_meter/crowd_meter_lens_" $crowdmeter ".png"}}
   }
}

{if $multiringcustomtexture ;check if a new texture is queued
   {unless {== $multiring none} ;check the texture is not set to default
      {fx_peak_stripes.tex set_bitmap {sprint "ui/track/multiplier_ring/fx_peak_stripes_" $multiring ".png"}}
      {multiplier_meter_glow.tex set_bitmap {sprint "ui/track/multiplier_ring/multiplier_meter_glow_" $multiring ".png"}}
      {multiplier_meter.tex set_bitmap {sprint "ui/track/multiplier_ring/multiplier_meter_" $multiring ".png"}}
      {streak_meter_bg.tex set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_bg_" $multiring ".png"}}
      {streak_meter_bg_vox.tex set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_bg_vox_" $multiring ".png"}}
      {streak_meter_lens.tex set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_lens_" $multiring ".png"}}
      ;{streak_meter_plate_fc.tex set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_plate_fc_" $multiring ".png"}}
      {streak_meter_plate.tex set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_plate_" $multiring ".png"}}
   }
}

{if $odbarcustomtexture ;check if a new texture is queued
   {unless {== $odbar none} ;check the texture is not set to default
      {fx_rising_sun.tex set_bitmap {sprint "ui/track/overdrive_bar/fx_rising_sun_" $odbar ".png"}}
      {overdrive_meter_background_fill.tex set_bitmap {sprint "ui/track/overdrive_bar/overdrive_meter_background_fill_" $odbar ".png"}}
      {overdrive_meter_glass.tex set_bitmap {sprint "ui/track/overdrive_bar/overdrive_meter_glass_" $odbar ".png"}}
      {player_meter_long_lens.tex set_bitmap {sprint "ui/track/overdrive_bar/player_meter_long_lens_" $odbar ".png"}}
      {player_meter_long.tex set_bitmap {sprint "ui/track/overdrive_bar/player_meter_long_" $odbar ".png"}}
   }
}

{if $railscustomtexture ;check if a new texture is queued
   {unless {== $rails none} ;check the texture is not set to default
      {smasher_plate_bracket.tex iterate_refs $ref {$ref set alpha_cut true}} ;alpha_cut fixes some specific issues where the transparant part of one texture "cuts" into another texture in use
      {beat_marker.tex set_bitmap {sprint "ui/track/rails/beat_marker_" $rails ".png"}}
      {rails.tex set_bitmap {sprint "ui/track/rails/rails_" $rails ".png"}}
      {rails_keyboard.tex set_bitmap {sprint "ui/track/rails/rails_" $rails ".png"}}
      {rails_rg.tex set_bitmap {sprint "ui/track/rails/rails_" $rails ".png"}}
      {smasher_plate_bracket.tex set_bitmap {sprint "ui/track/rails/smasher_plate_bracket_" $rails ".png"}}
   }
}

{if $scorecustomtexture ;check if a new texture is queued
   {unless {== $scoretex none} ;check the texture is not set to default
      {score_meter_wipe.tex set_bitmap {sprint "ui/track/score/score_meter_wipe_" $scoretex ".png"}}
      {score_star_frame.tex set_bitmap {sprint "ui/track/score/score_star_frame_" $scoretex ".png"}}
      {score_star_gold.tex set_bitmap {sprint "ui/track/score/score_star_gold_" $scoretex ".png"}}
      {scoreboard_frame.tex set_bitmap {sprint "ui/track/score/scoreboard_frame_" $scoretex ".png"}}
      {scoreboard_lens.tex set_bitmap {sprint "ui/track/score/scoreboard_lens_" $scoretex ".png"}}
      {star_multiplier_meter_frame.tex set_bitmap {sprint "ui/track/score/star_multiplier_meter_frame_" $scoretex ".png"}}
      {star_multiplier_meter_lens.tex set_bitmap {sprint "ui/track/score/star_multiplier_meter_lens_" $scoretex ".png"}}
      {tour_icon.tex set_bitmap {sprint "ui/track/score/tour_icon_" $scoretex ".png"}}
   }
}

{if $flamescustomtexture ;check if a new texture is queued
   {unless {== $flames none} ;check the texture is not set to default
      {gem_cap.tex set_bitmap {sprint "ui/track/flames/gem_cap_" $flames ".png"}}
      {broken_glass01.tex set_bitmap {sprint "ui/track/flames/broken_glass01_" $flames ".png"}}
      {broken_glass01_neg.tex set_bitmap {sprint "ui/track/flames/broken_glass01_neg_" $flames ".png"}}
      {broken_glass02.tex set_bitmap {sprint "ui/track/flames/broken_glass02_" $flames ".png"}}
      {flare_gtr_inner.tex set_bitmap {sprint "ui/track/flames/flare_gtr_inner_" $flames ".png"}}
      {flare_gtr_outer.tex set_bitmap {sprint "ui/track/flames/flare_gtr_outer_" $flames ".png"}}
      {flare_gtr_style.tex set_bitmap {sprint "ui/track/flames/flare_gtr_style_" $flames ".png"}}
      {flare_inner.tex set_bitmap {sprint "ui/track/flames/flare_inner_" $flames ".png"}}
      {flare_outer.tex set_bitmap {sprint "ui/track/flames/flare_outer_" $flames ".png"}}
      {flare_style.tex set_bitmap {sprint "ui/track/flames/flare_style_" $flames ".png"}}
      {fx_smasher_smoke.tex set_bitmap {sprint "ui/track/flames/fx_smasher_smoke_" $flames ".png"}}
      {radial_shockwave.tex set_bitmap {sprint "ui/track/flames/radial_shockwave_" $flames ".png"}}
      {spark.tex set_bitmap {sprint "ui/track/flames/sparks_" $flames ".png"}}
      {sparks_radial.tex set_bitmap {sprint "ui/track/flames/sparks_radial_" $flames ".png"}}
      {sparks_vertical.tex set_bitmap {sprint "ui/track/flames/sparks_vertical_" $flames ".png"}}
   }
}

{if $smashercustomtexture ;check if a new texture is queued
   {unless {== $smasher none} ;check the texture is not set to default
      {gem_smashers_guitar_nomip.tex set_bitmap {sprint "ui/track/smashers/gem_smashers_guitar_" $smasher ".png"}}
      {gem_smashers_guitar.tex set_bitmap {sprint "ui/track/smashers/gem_smashers_guitar_" $smasher ".png"}}
      {gem_smashers_drum_nomip.tex set_bitmap {sprint "ui/track/smashers/gem_smashers_drum_" $smasher ".png"}}
      {gem_smashers_drum.tex set_bitmap {sprint "ui/track/smashers/gem_smashers_drum_" $smasher ".png"}}
      {square_smasher_bright_green.tex set_bitmap {sprint "ui/track/smashers/square_smasher_bright_green_" $smasher ".png"}}
      {square_smasher_bright_red.tex set_bitmap {sprint "ui/track/smashers/square_smasher_bright_red_" $smasher ".png"}}
      {square_smasher_bright_yellow.tex set_bitmap {sprint "ui/track/smashers/square_smasher_bright_yellow_" $smasher ".png"}}
      {square_smasher_bright_blue.tex set_bitmap {sprint "ui/track/smashers/square_smasher_bright_blue_" $smasher ".png"}}
      {square_smasher_bright_orange.tex set_bitmap {sprint "ui/track/smashers/square_smasher_bright_orange_" $smasher ".png"}}
   }
}

{if $gemcustomtexture ;check if a new texture is queued
   {unless {== $gem none} ;check the texture is not set to default
      {gem_cymbal_diffuse.tex set_bitmap {sprint "ui/track/gems/gem_cymbal_diffuse_" $gem ".png"}}
      {gem_cymbal_ems.tex set_bitmap {sprint "ui/track/gems/gem_cymbal_ems_" $gem ".png"}}
      {gem_mash_green_emmisive.tex set_bitmap {sprint "ui/track/gems/gem_mash_green_emmisive_" $gem ".png"}}
      {gem_mash_red_emmisive.tex set_bitmap {sprint "ui/track/gems/gem_mash_red_emmisive_" $gem ".png"}}
      {gem_mash_yellow_emmisive.tex set_bitmap {sprint "ui/track/gems/gem_mash_yellow_emmisive_" $gem ".png"}}
      {gem_mash_blue_emmisive.tex set_bitmap {sprint "ui/track/gems/gem_mash_blue_emmisive_" $gem ".png"}}
      {gem_mash_orange_emmisive.tex set_bitmap {sprint "ui/track/gems/gem_mash_orange_emmisive_" $gem ".png"}}
      {gliss_gems.tex set_bitmap {sprint "ui/track/gems/gliss_gems_" $gem ".png"}}
      {prism_gems.tex set_bitmap {sprint "ui/track/gems/prism_gems_" $gem ".png"}}
      {prism_gem_emissive.tex set_bitmap {sprint "ui/track/gems/prism_gem_emissive_" $gem ".png"}}
      {prism_gem_keyboard_style.tex set_bitmap {sprint "ui/track/gems/prism_gem_keyboard_style_" $gem ".png"}}
   }
}

{if $sustaincustomtexture ;check if a new texture is queued
   {unless {== $sustain none} ;check the texture is not set to default
      {gem_tails.tex set_bitmap {sprint "ui/track/sustains/gem_tails_" $sustain ".png"}}
   }
}
      
{if $voxarrowcustomtexture ;check if a new texture is queued
   {unless {== $voxarrow none} ;check the texture is not set to default
      {pitch_arrow_lead_c.tex set_bitmap {sprint "ui/track/voxarrow/arrow_lead_c_" $voxarrow ".png"}}
      {arrow_lead_outline.tex set_bitmap {sprint "ui/track/voxarrow/arrow_lead_outline_" $voxarrow ".png"}}
   }
}

{if $voxhwcustomtexture ;check if a new texture is queued
   {unless {== $voxhw none} ;check the texture is not set to default
      {talky_mask.tex set_bitmap {sprint "ui/track/voxhw/talky_mask_" $voxhw ".png"}}
      {vocals_bg_combined.tex set_bitmap {sprint "ui/track/voxhw/vocal_bg_combined_" $voxhw ".png"}}
      {vocal_bg_notonic.tex set_bitmap {sprint "ui/track/voxhw/vocal_bg_notonic_" $voxhw ".png"}}
   }
}

{if $keyboardcustomtexture ;check if a new texture is queued
   {unless {== $keyboard none} ;check the texture is not set to default
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys}
         {track_lanes_keyboard.tex set_bitmap {sprint "ui/track/keyboards/track_lanes_keyboard_" $keyboard ".png"}}
         {track_lanes_keyboard_press.tex set_bitmap {sprint "ui/track/keyboards/track_lanes_keyboard_press_" $keyboard ".png"}}
         {gem_smasher_sharp_diffuse_nomip.tex set_bitmap {sprint "ui/track/keyboards/gem_smasher_sharp_diffuse_nomip_" $keyboard ".png"}}
         {gem_mash_prokeys_ems.tex set_bitmap {sprint "ui/track/keyboards/gem_mash_prokeys_ems_" $keyboard ".png"}}
         {gem_mash_prokeys.tex set_bitmap {sprint "ui/track/keyboards/gem_mash_prokeys_" $keyboard ".png"}}
      }
   }
}

;watermarking for ch mode via coloring the rails
{if {modifier_mgr is_modifier_active mod_chmode} ;if clone hero mode is currently enabled (must run last for watermark)
   {rails.tex set_bitmap "ui/track/custom_track_textures/rails_drunk.png"}
   {rails_keyboard.tex "set_bitmap ui/track/custom_track_textures/rails_drunk.png"}
   {rails_rg.tex set_bitmap "ui/track/custom_track_textures/rails_drunk.png"}
   {smasher_plate_bracket.tex set_bitmap "ui/track/custom_track_textures/smasher_plate_bracket_drunk.png"}
}

;after all of the queued texture updates are completed, set them to false so they do not run again until a new texture is queued via overshell
{set $rb2uicustomtexture FALSE}
{set $rb4uicustomtexture FALSE}
{set $rb2trkcustomtexture FALSE}
{set $rb4trkcustomtexture FALSE}
{set $animatedhighwaycustomtexture FALSE}
{set $animatedgemscustomtexture FALSE}
{set $animatedsmasherscustomtexture FALSE}
{set $highwaycustomtexture FALSE}
{set $spotlightcustomtexture FALSE}
{set $emissivecustomtexture FALSE}
{set $keyboardcustomtexture FALSE}
)
#define NO_BRE_HANDLER
(
   {if {&& {modifier_mgr is_modifier_active mod_nobre} $imabigboy} ;check if we have no bre active, and we havent restarted already on this song
      {if {! $already_restarted} ;cheap attempt to fix the "notes too quick bug" by restarting once automatically on initial song start, this will at least work in black bg
         {do ;do
            {set $imabigboy FALSE} ;tell the logic we have restarted once to switch to expert
            {set $already_restarted TRUE} ;also tell the logic we
            {{{beatmatch active_player 0} get_user} set_difficulty kDifficultyExpert} ;since we have entered the track on easy, set the player to expert to enable no bre behavior
            {game_restart} ;quick restart the song
         }
      }
   }
)
#define TRACK_PANEL_HANDLERS
(
   (enter ;when the track is entered
      {game add_sink $this} ;set up the game with the vanilla sinks
      {beatmatch foreach_active_player $player ;handle adding the appropriate callbacks to each player
         {switch {$player instrument} ;switch based off the currently loaded instrument
            (bass {$player add_sink fc_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)}) ;add our custom fc checking callbacks to the currently loaded player
            (real_guitar {$player add_sink fc_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)}) ;add our custom fc checking callbacks to the currently loaded player
            (real_bass {$player add_sink fc_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)}) ;add our custom fc checking callbacks to the currently loaded player
            (keys {$player add_sink fc_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)}) ;add our custom fc checking callbacks to the currently loaded player
            (real_keys {$player add_sink fc_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)}) ;add our custom fc checking callbacks to the currently loaded player
            (guitar {$player add_sink fc_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)}) ;add our custom fc checking callbacks to the currently loaded player
            (drum {$player add_sink fc_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)}) ;add our custom fc checking callbacks to the currently loaded player
            (real_drum {$player add_sink fc_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)}) ;add our custom fc checking callbacks to the currently loaded player
         }
      }
      {$this set_showing {! {gamemode in_mode practice}}}
   )
   (exit ;when the track is exited
      {if {exists animated_gems} ;check if the above task is running
         {delete animated_gems} ;delete the task if running
      }
      {if {exists animated_smashers} ;check if the above task is running
         {delete animated_smashers} ;delete the task if running
      }
      {if {exists animated_highway} ;check if the above task is running
         {delete animated_highway} ;delete the task if running
      }
      {game remove_sink $this} ;remove the vanilla sinks
   )
   (unison_hit)
   (set_track_out)
   (set_track_in)
   (animate_track
      ($start $end $period $units)
   )
   (animate_track_out)
   (animate_track_out_fast)
   (animate_track_in_fast)
   (finish_load
      {$this set_showing FALSE}
      {$this set_track_out}
   )
   (intro_start
      {$this track_reset}
      {$this set_showing TRUE}
      {$this set_track_in}
   )
   (intro_skip
      {$this track_reset}
      {$this set_showing TRUE}
      {$this set_track_out}
      NO_BRE_HANDLER ;restart the game, and switch to expert if in no bre mode
   )
   (on_reset
      {beatmatch foreach_active_player $m {$m on_new_track}}
   )
   (on_extend
      NO_BRE_HANDLER ;restart the game, and switch to expert if in no bre mode
      TRACK_TEXTURE_HANDLER ;here is where we setup the custom track
      {$this play_intro} ;play the intro to the track
      {if {&& {exists gamemode}{gamemode get play_track_intro_sfx}} ;if we are allowed to play the track intro sound effects for this track entry
         {$this play_seq track_beg.cue} ;play the track sound effects
         {unless
            {|| ;check for a vareity of game modes where song speed is not allowed to be adjusted
               {gamemode in_mode pro_song_lessons_keyboard} {gamemode in_mode pro_song_lessons_real_guitar}
               {gamemode in_mode pro_song_lessons_real_bass} {gamemode in_mode drum_freestyle}
               {gamemode in_mode trainer} {gamemode in_mode trainer_drums} {gamemode in_mode trainer_pro_drums}
               {gamemode in_mode trainer_real_guitar} {gamemode in_mode trainer_pro_keyboard}
               #ifdef HX_XBOX {gamemode in_mode audition} #endif ;audition is xbox only, ps3 will crash if you check for it
               {&& {gamemode in_mode practice} {> {gamecfg get practice_speed} 0}} ;if we are in practice and selected something other than 100% speed
            }
            {beatmatch set_music_speed $speedmod} ;apply the current selected speed in game
         }
         {if {&& {gamemode in_mode practice} {> {gamecfg get practice_speed} 0}} ;if we are in practice and selected something other than 100% speed
            {beatmatch set_music_speed $modifier} ;apply the practice specific speed selection in game
         }
      }
   )
)
{new
   TrackPanel
   coop_track_panel
   (file "track/trackpanel.milo")
   TRACK_PANEL_HANDLERS
}
{func get_track_panel
   {gamemode get track_panel}
}
{set $playback_file ""}